<html>
<head>
<meta charset="utf-8" /> 
<style>
div.main {
	position:fixed;
	top:0px;
    bottom:0px;
    left:0px;
    right:0px;
}

div.flist {
	float: left;
	position: fixed;
	width: 20%;
	height: 100%;
	background-color: slategray;
	overflow: scroll;
}
div.file {
	position: relative;
	background-color: gray;
	color: white;
	font-family: Helvetica, Arial, sans-serif;
	font-size: large;
	height: 5%;
	text-align: left;
	margin: 3%;
	margin-right: 4%;
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
    display:flex;
    align-items: center;
    justify-content: left;
	padding-left: 5%;
	overflow: visible;

	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-o-user-select: none;
	user-select: none;
}
div.file:hover {
	background-color: lightgray;
	color: white;
    box-shadow: 7px 14px 26px #000000;
	overflow: visible;
}
div.file:active {
	margin-right: 3%;
	margin-left: 4%;
	margin-top: 4%;
	margin-bottom: -1%;
}

div.viewpanel {
	position: relative;
	float: right;
	width: 80%;
	height: 100%;
	background-color: slategray;
	z-index: 0;
	overflow: visible;
}
div.viewholder {
//	border: 5px solid red;
	background-color: white;
	position: relative;
	width: 98%;
	height: 98%;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
}
div.viewer {
//	border: 5px solid green;
	overflow: visible;
	display: block;
	background-color: white;
	position: relative;
	width: 98.2%;
	height: 97%;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
}

.can {
	margin: 0 auto;
	position: relative;
}

</style>
</head>
<body>

<div class="main">
	<div class="flist" id="menu">
		<!-- <div class="file">File1.txt</div> -->
	</div>
	<div class="viewpanel">
		<div class="viewholder">
			<div class="viewer" id="viewer">
				<canvas id="mycan" class="can"></canvas>
			</div>
		</div>
	</div>
</div>

<script src='testoutput.js'></script> <!-- must be above other code -->
<script>
function setupCanvas(viewerid,canvasid) {
	// size must be reset because CSS sizing doesn't work on canvases.
	canvas = document.getElementById(canvasid);
	par = document.getElementById(viewerid);
	wextra = 0;
	hextra = 0;
	var wdt = par.clientWidth - wextra;
	var ht = par.clientHeight - hextra;
	canvas.setAttribute('height',ht+"px");
	canvas.setAttribute('width',wdt+"px");
	return canvas;
}

/* Map from pset coordinates to canvas coordinates
   Example: pset has x-coordinates from -50 to 100,
   canvas x coordinates go from 0 to 600.
   consider a single point, and its x coordinate.
   first lets translate x so it goes from 0 to 150. psetx=(inputx-minx).
   now psetx / pset width is proportional to canvas x / canvas width
   ox/ow = cx/cw, therefore cx = (ox/ow)*cw
   (100-(-50))/150 * 600 => 600
   (-50-(-50))/150 * 600 => 0
   (  0-(-50))/150 * 600 => 200
   now, also cx = ox * ( cw/ow ), cw/ow can be the 'xratio', and we have
   different ratio y direction, y ratio. in order to keep the pset's
   original aspect ratio, only multiply by the lowest of these two ratios.
*/
class PointMapper {
	constructor( pset, canvas ) {
		this.canvas = canvas;
		this.bbox = findBoundingBox( pset );
		console.log("mapper bbox",this.bbox,pset);
		this.psetw = this.bbox.maxx-this.bbox.minx;
		this.pseth = this.bbox.maxy-this.bbox.miny;
		var wratio = (this.canvas.width-1) / this.psetw;
		var hratio = (this.canvas.height-1) / this.pseth;
		this.ratio = Math.min(wratio,hratio);
	}
	x( psetx ) {
		return (psetx-this.bbox.minx)*this.ratio;
	}
	y( psety ) {
		return (psety-this.bbox.miny)*this.ratio;
	}
}

function findBoundingBox( Pset ) {
	var minx = Pset[0][0][0], miny = Pset[0][0][1];
	var maxx = minx, maxy = miny;
	for ( var i=0; i<Pset.length; i++ ) {
		var contour = Pset[i];
		for ( var j=0; j<contour.length; j++ ) {
			var point = contour[j];
			maxx = Math.max(maxx,point[0]);
			maxy = Math.max(maxy,point[1]);
			minx = Math.min(minx,point[0]);
			miny = Math.min(miny,point[1]);
		}
	}
	return {"minx":minx,"miny":miny,"maxx":maxx,"maxy":maxy};
}

function flatten( data ) {
	vertices = [];
	dimensions = data[0][0].length;
	for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dimensions; d++) vertices.push(data[i][j][d]);
        }
	}
	return vertices;
}

function makeTriPset( mainPset, tris, mapr ) {
	dimensions = mainPset[0][0].length;
	vertices = flatten( mainPset );
	trianglePset = [];
	for (var i = 0; i < tris.length; i+=3) {
		triContour = [];
		for (var j = 0; j < 3; j++ ) {
		    ptindex = tris[i+j];
			x = vertices[ ptindex * dimensions + 0 ];
			y = vertices[ ptindex * dimensions + 1 ];
			triContour.push( [x,y] );
		}
		trianglePset.push( triContour );
    }
	console.log(trianglePset);
	return trianglePset;
}

function drawPset( pset, canvas, mapr, labels, lastcontour, fill ) {
	ctx = canvas.getContext('2d');
	todraw = Math.min(pset.length,lastcontour);
	for ( var i=0; i < todraw; i++ ) {
		var contour = pset[i];
		ctx.beginPath();
		ctx.moveTo( mapr.x(contour[0][0]), mapr.y(contour[0][1]) );
		var fs = 'hsla('+360*(i*3)/(pset.length*3-1)+',100%,50%,0.05)';
		ctx.fillStyle = fs;
		console.log('fs',i*3,pset.length*3-1,fs );
		for ( var j=0; j < contour.length; j++ ) {
			var point = contour[j];
			ctx.lineTo( mapr.x(point[0]), mapr.y(point[1]) );
			if ( labels ) { 
				ctx.font="40px Verdana";
				ctx.fillText( j, mapr.x(point[0]), mapr.y(point[1])+30 );
				ctx.fillText( j, mapr.x(point[0])-30, mapr.y(point[1])+30 );
			}
		}
		ctx.closePath();
		if (fill) ctx.fill();
		ctx.stroke();
	}

}

// create a function to respond to filename clicks, used by build_testmenu
function mkfunc( testname ) {
    return function() {
		drawTest( testOutput[testname]["json"], testOutput[testname]["triangles"] );
    }
};

function build_testmenu() {
	// load testOutput, from testoutput.js, and make a menu
	// testoutput.js is generated by cargo test -- --test-threads=1
	// and included in the main .html file as < script src = "testoutput.js" />
	for (var testname in testOutput) {
	    var menu = document.getElementById("menu");
	    var filenode = document.createElement("div");
		filenode.setAttribute( "class", "file" );
	    filenode.innerHTML = testname;
	    filenode.addEventListener('click', mkfunc(testname) );
	    menu.appendChild(filenode);
	}
}

function drawTest( pset, tris ) {
	ctx = canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height);
	mapr = new PointMapper( pset, canvas );
	triPset = makeTriPset( pset, tris, mapr ); 
	drawPset( pset, canvas, mapr, false, 1, false );
	for ( var i = 0; i < 6; i ++ ) { 
		drawPset( triPset, canvas, mapr, false, 39, true );
	}
}

function main() {
	canvas = setupCanvas("viewer","mycan");

	var testPset = [[[661,112],[661,96],[666,96],[666,87],[743,87],[771,87],[771,114],[750,114],[750,113],[742,113],[742,106],[710,106],[710,113],[666,113],[666,112]]];

	var testTris = [14, 0, 1, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 11, 
		12, 13, 14, 1, 2, 4, 6, 8, 11, 13, 14, 14, 2, 4, 4, 8, 10, 11, 14, 
		4, 4, 10, 11];

	drawTest( testPset, testTris, canvas );

	build_testmenu();
}

main();

</script>


</body>
</html>



