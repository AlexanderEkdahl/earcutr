<html>
<head>
<meta charset="utf-8" /> 
<style>
div.main {
	position:fixed;
	top:0px;
    bottom:0px;
    left:0px;
    right:0px;
}

div.leftpanel {
	float: left;
	position: fixed;
	width: 20%;
	height: 100%;
	background-color: slategray;
}

div.flist {
	float: left;
	position: relative;
	width: 100%;
	height: 80%;
	background-color: slategray;
	overflow: scroll;
}

div.file {
	position: relative;
	background-color: gray;
	color: white;
	font-family: Helvetica, Arial, sans-serif;
	font-size: 2em;
	height: 5%;
	text-align: left;
	margin: 3%;
	margin-right: 4%;
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
    display:flex;
    align-items: center;
    justify-content: left;
	padding-left: 5%;
	overflow: visible;

	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-o-user-select: none;
	user-select: none;
}
div.file:hover {
	background-color: lightgray;
	color: white;
    box-shadow: 7px 14px 26px #000000;
	overflow: visible;
}
div.file:active {
	margin-right: 3%;
	margin-left: 4%;
	margin-top: 4%;
	margin-bottom: -1%;
}



div.reportpanel {
	float: left;
	position: relative;
	width: 100%;
	height: 20%;
	background-color: slategray;
	font-family: Helvetica, Arial, sans-serif;
	font-size: 2em;
//	padding: 5%;
//	border: 1px solid black;
}

div.report {
	background-color: white;
	position: relative;
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
	margin: 3%;
	margin-right: 4%;
	height: 82.4%;
	overflow: scroll;
//	border: 1px solid red;
	padding: 2%;
	white-space: pre-wrap;
}



div.viewpanel {
	position: relative;
	float: right;
	width: 80%;
	height: 100%;
	background-color: slategray;
	z-index: 0;
	overflow: visible;
}
div.viewholder {
//	border: 5px solid red;
	background-color: white;
	position: relative;
	width: 98%;
	height: 98%;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
}
div.viewer {
//	border: 5px solid green;
	overflow: visible;
	display: block;
	background-color: white;
	position: relative;
	width: 98.2%;
	height: 97%;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
}

.can {
	margin: 0 auto;
	position: relative;
}

</style>
</head>
<body>

<div class="main">
	<div class="leftpanel">
		<div class="flist" id="menu">
			<!-- <div class="file">File1.txt</div> -->
		</div>
		<div class="reportpanel">
			<div class="report" id="report">
				<!-- blah blah blah -->
			</div>
		</div>
	</div>
	<div class="viewpanel">
		<div class="viewholder">
			<div class="viewer" id="viewer">
				<canvas id="mycan" class="can"></canvas>
			</div>
		</div>
	</div>
</div>

<script>module = {}</script>
<script src='testoutput.js'></script> <!-- must be above other code -->
<script src='earcut.js'></script>
<script>
function setupCanvas(viewerid,canvasid) {
	// size must be reset because CSS sizing doesn't work on canvases.
	canvas = document.getElementById(canvasid);
	par = document.getElementById(viewerid);
	wextra = 0;
	hextra = 0;
	var wdt = par.clientWidth - wextra;
	var ht = par.clientHeight - hextra;
	canvas.setAttribute('height',ht+"px");
	canvas.setAttribute('width',wdt+"px");
	return canvas;
}

/* Map from pset coordinates to canvas coordinates
   Example: pset has x-coordinates from -50 to 100,
   canvas x coordinates go from 0 to 600.
   consider a single point, and its x coordinate.
   first lets translate x so it goes from 0 to 150. psetx=(inputx-minx).
   now psetx / pset width is proportional to canvas x / canvas width
   ox/ow = cx/cw, therefore cx = (ox/ow)*cw
   (100-(-50))/150 * 600 => 600
   (-50-(-50))/150 * 600 => 0
   (  0-(-50))/150 * 600 => 200
   now, also cx = ox * ( cw/ow ), cw/ow can be the 'xratio', and we have
   different ratio y direction, y ratio. in order to keep the pset's
   original aspect ratio, only multiply by the lowest of these two ratios.
*/
class PointMapper {
	constructor( pset, canvas ) {
		this.canvas = canvas;
		this.bbox = findBoundingBox( pset );
		//console.log("mapper bbox",this.bbox,pset);
		this.psetw = this.bbox.maxx-this.bbox.minx;
		this.pseth = this.bbox.maxy-this.bbox.miny;
		var wratio = (this.canvas.width-1) / this.psetw;
		var hratio = (this.canvas.height-1) / this.pseth;
		this.ratio = Math.min(wratio,hratio);
	}
	x( psetx ) {
		return (psetx-this.bbox.minx)*this.ratio;
	}
	y( psety ) {
		return (psety-this.bbox.miny)*this.ratio;
	}
}

function findBoundingBox( Pset ) {
	var minx = Pset[0][0][0], miny = Pset[0][0][1];
	var maxx = minx, maxy = miny;
	for ( var i=0; i<Pset.length; i++ ) {
		var contour = Pset[i];
		for ( var j=0; j<contour.length; j++ ) {
			var point = contour[j];
			maxx = Math.max(maxx,point[0]);
			maxy = Math.max(maxy,point[1]);
			minx = Math.min(minx,point[0]);
			miny = Math.min(miny,point[1]);
		}
	}
	return {"minx":minx,"miny":miny,"maxx":maxx,"maxy":maxy};
}

function flatten( data ) {
	vertices = [];
	dimensions = data[0][0].length;
	for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dimensions; d++) vertices.push(data[i][j][d]);
        }
	}
	return vertices;
}

function makeTriPset( mainPset, tris, mapr ) {
	dimensions = mainPset[0][0].length;
	vertices = flatten( mainPset );
	trianglePset = [];
	for (var i = 0; i < tris.length; i+=3) {
		triContour = [];
		for (var j = 0; j < 3; j++ ) {
		    ptindex = tris[i+j];
			x = vertices[ ptindex * dimensions + 0 ];
			y = vertices[ ptindex * dimensions + 1 ];
			triContour.push( [x,y] );
		}
		trianglePset.push( triContour );
    }
	//console.log(trianglePset);
	return trianglePset;
}

function drawPset( pset, canvas, mapr, labels, lastcontour, fill ) {
	ctx = canvas.getContext('2d');
	todraw = Math.min(pset.length,lastcontour);
	for ( var i=0; i < todraw; i++ ) {
		//console.log("dpset"+i);
		var contour = pset[i];
		ctx.beginPath();
		ctx.moveTo( mapr.x(contour[0][0]), mapr.y(contour[0][1]) );
		var fs = 'hsla('+360*(i*3)/(pset.length*3-1)+',100%,50%,0.05)';
		ctx.fillStyle = fs;
		//console.log('fs',i*3,pset.length*3-1,fs );
		for ( var j=0; j < contour.length; j++ ) {
			var point = contour[j];
			ctx.lineTo( mapr.x(point[0]), mapr.y(point[1]) );
			if ( labels ) { 
				ctx.font="3em Verdana";
				ctx.fillStyle = "black";
				ctx.fillText( i+','+j, mapr.x(point[0]), mapr.y(point[1])+20 );
				ctx.fillText( i+','+j, mapr.x(point[0]), mapr.y(point[1])+20 );
				ctx.fillStyle = fs;
				console.log(i+','+j, mapr.x(point[0]), mapr.y(point[1]));
			}
		}
		ctx.closePath();
		if (fill) ctx.fill();
		ctx.stroke();
	}

}

// create a function to respond to filename clicks, used by build_testmenu
function mkfunc( testname, canvas ) {
    return function() {
		canvas = document.getElementById( canvas.id );
		drawTest( testOutput[testname]["json"], 
				  testOutput[testname]["triangles"],
				  testOutput[testname]["report"],
				  canvas );
    }
};

function build_testmenu( canvasid ) {
	// load testOutput, from testoutput.js, and make a menu
	// testoutput.js is generated by cargo test -- --test-threads=1
	// and included in the main .html file as < script src = "testoutput.js" />

	// this section creates earcut.js versions of each test from testOutput
	for (var testname in testOutput) {
		var data = earcut.flatten( testOutput[testname]["json"] );
		console.log("-------earcut start"+data);
		var result = earcut(data.vertices, data.holes, data.dimensions);
		console.log("-------earcut end");
		testOutput[testname+"_ecut"] = [];
		testOutput[testname+"_ecut"]["json"] = testOutput[testname]["json"];
		testOutput[testname+"_ecut"]["triangles"] = result;
		testOutput[testname+"_ecut"]["pass"] = "0";
		testOutput[testname+"_ecut"]["report"] = "num tris" + result.length/3;
	}
	names = Object.keys(testOutput);
	names.sort();
	// fill up the 'file' menu on the left hand side of the screen
	for (var i in names) {
		testname = names[i];
	    var menu = document.getElementById("menu");
	    var filenode = document.createElement("div");
		filenode.setAttribute( "class", "file" );
	    filenode.innerHTML = testname;
	    filenode.addEventListener('click', mkfunc(testname,canvasid) );
	    menu.appendChild(filenode);
	}
}

function drawTest( pset, tris, report, canvas ) {
	ctx = canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height);
	mapr = new PointMapper( pset, canvas );
	triPset = makeTriPset( pset, tris, mapr ); 
	drawPset( pset, canvas, mapr, true, pset.length, false );
//	for ( var i = 0; i < 6; i ++ ) { 
		todraw = triPset.length;
		drawPset( triPset, canvas, mapr, false, todraw, true );
//	}
    var reportbox = document.getElementById("report");
	reportbox.innerHTML = report + '<br/>' + tris;
}

function main() {
	canvas = setupCanvas("viewer","mycan");

	var testPset = [[[661,112],[661,96],[666,96],[666,87],[743,87],[771,87],[771,114],[750,114],[750,113],[742,113],[742,106],[710,106],[710,113],[666,113],[666,112]]];
	var testTris = [14, 0, 1, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 11, 
		12, 13, 14, 1, 2, 4, 6, 8, 11, 13, 14, 14, 2, 4, 4, 8, 10, 11, 14, 
		4, 4, 10, 11];
	var testReport = "default shape, " + testTris.length + " triangles";

	//drawTest( testPset, testTris, testReport, canvas );

	build_testmenu( canvas );
}

main();

</script>


</body>
</html>



