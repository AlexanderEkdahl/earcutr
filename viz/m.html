<html>
<head>
<meta charset="utf-8" /> 
<style>
body {
    font-size: 100%;
}
div.main {
	position:fixed;
	top:0px;
    bottom:0px;
    left:0px;
    right:0px;
}

div.leftpanel {
	float: left;
	position: fixed;
	width: 20%;
	height: 100%;
	background-color: slategray;
}

div.flist {
	float: left;
	position: relative;
	width: 100%;
	height: 75%;
	background-color: slategray;
	overflow: scroll;
}

.file, .file_fail {
	position: relative;
	color: white;
	font-family: Helvetica, Arial, sans-serif;
	font-size: 1em;
	height: 5%;
	text-align: left;
	margin: 3%;
	margin-right: 4%;
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
    display:flex;
    align-items: center;
    justify-content: left;
	padding-left: 5%;
	overflow: visible;
	cursor: default;

	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-o-user-select: none;
	user-select: none;
}

.file {
	background-color: gray;
}

.file_fail {
	background-color: red;
}

.file:hover,.file_fail:hover {
	color: white;
    box-shadow: 7px 14px 26px #000000;
	overflow: visible;
}
.file:hover {
	background-color: lightgray;
}
.file_fail:hover {
	background-color: pink;
}
.file:active,.file_fail:active {
	margin-right: 3%;
	margin-left: 4%;
	margin-top: 4%;
	margin-bottom: -1%;
}

div.controlpanel {
	float: left;
	position: relative;
	width: 100%;
	height: 10%;
	background-color: slategray;
	font-family: Helvetica, Arial, sans-serif;
	font-size: 1em;
//	padding: 5%;
//	border: 1px solid black;
}

div.controlpanel {
//	float: right;
	position: relative;
	width: 100%;
	height: 5%;
	background-color: slategray;
	font-family: Helvetica, Arial, sans-serif;
	font-size: 1em;
	display: flex;
//	padding: 5%;
//	border: 1px solid black;
}

div.controlbutton {
//	position: relative;
	background-color: gray;
	color: white;
	font-family: Helvetica, Arial, sans-serif;
	font-size: 1em;
//	width: 20%;
	height: 75%;
	text-align: center;
	margin-left: 3%;
	margin-top: 2%;
	margin-down: 2%;
	margin-right: 0%;
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
//    display:flex;
display: inline-block;
//    align-items: center;
//    justify-content: left;
	padding-left: 2%;
	padding-right: 2%;
	padding: 1%em;
	overflow: visible;
	cursor: default;

	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-o-user-select: none;
	user-select: none;
}
div.controlbutton:hover {
	background-color: lightgray;
	color: white;
    box-shadow: 7px 14px 26px #000000;
	overflow: visible;
}
div.controlbutton:active {
	margin-right: -2%;
	margin-left: 5%;
	margin-top: 4%;
	margin-bottom: -1%;
}

div.reportpanel {
	float: left;
	position: relative;
	width: 100%;
	height: 20%;
	background-color: slategray;
	font-family: Helvetica, Arial, sans-serif;
	font-size: 1em;
//	padding: 5%;
//	border: 1px solid black;
}

div.report {
	background-color: white;
	position: relative;
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
	margin: 3%;
	margin-right: 4%;
	height: 82.4%;
	overflow: scroll;
//	border: 1px solid red;
	padding: 2%;
	white-space: pre-wrap;
}



div.viewpanel {
	position: relative;
	float: right;
	width: 80%;
	height: 100%;
	background-color: slategray;
	z-index: 0;
	overflow: visible;
}
div.viewholder {
//	border: 5px solid red;
	background-color: white;
	position: relative;
	width: 98%;
	height: 98%;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
    box-shadow: 5px 10px 18px #000000;
	z-index: 1;
}
div.viewer {
//	border: 5px solid green;
	overflow: visible;
	display: block;
	background-color: white;
	position: relative;
	width: 98.2%;
	height: 97%;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
}

.can {
	margin: 0 auto;
	position: relative;
}

</style>
</head>
<body>

<div class="main">
	<div class="leftpanel">
		<div class="flist" id="menu">
			<!-- <div class="file">File1.txt</div> -->
		</div>
		<div class="controlpanel">
			<div class="controlbutton" id="labelsbutton">labels</div>
			<div class="controlbutton" id="trisbutton">triangles</div>
			<div class="controlbutton" id="earcutbutton">earcut.js</div>
		</div>
		<div class="reportpanel">
			<div class="report" id="report">
				<!-- blah blah blah -->
			</div>
		</div>
	</div>
	<div class="viewpanel">
		<div class="viewholder">
			<div class="viewer" id="viewer">
				<canvas id="mycan" class="can"></canvas>
			</div>
		</div>
	</div>
</div>

<script>module = {}</script>
<script src='earcut.js'></script>
<script src='testoutput.js'></script> <!-- defines var testOutput=[]; -->
<script>
var currentTestName = "";
var labelsToggle = 0;
var fillToggle = 1;
var labelmap = [];

function setupCanvas(viewerid,canvasid) {
	// size must be reset because CSS sizing doesn't work on canvases.
	canvas = document.getElementById(canvasid);
	par = document.getElementById(viewerid);
	wextra = 0;
	hextra = 0;
	var wdt = par.clientWidth - wextra;
	var ht = par.clientHeight - hextra;
	canvas.setAttribute('height',ht+"px");
	canvas.setAttribute('width',wdt+"px");

	canvas.addEventListener("wheel", function (ev) {
		console.log("wheel");
		console.log(ev.deltaX);
		console.log(ev.deltaY);
		console.log(ev.offsetX);
		console.log(ev.offsetY);
		redraw( canvas.id );
	} );

	return canvas;
}

/* Map from pset coordinates to canvas coordinates
   Example: pset has x-coordinates from -50 to 100,
   canvas x coordinates go from 0 to 600.
   consider a single point, and its x coordinate.
   first lets translate x so it goes from 0 to 150. psetx=(inputx-minx).
   now psetx / pset width is proportional to canvas x / canvas width
   ox/ow = cx/cw, therefore cx = (ox/ow)*cw
   (100-(-50))/150 * 600 => 600
   (-50-(-50))/150 * 600 => 0
   (  0-(-50))/150 * 600 => 200
   now, also cx = ox * ( cw/ow ), cw/ow can be the 'xratio', and we have
   different ratio y direction, y ratio. in order to keep the pset's
   original aspect ratio, only multiply by the lowest of these two ratios.
*/
class PointMapper {
	constructor( pset, canvas ) {
		this.canvas = canvas;
		this.bbox = findBoundingBox( pset );
		//console.log("mapper bbox",this.bbox,pset);
		this.psetw = this.bbox.maxx-this.bbox.minx;
		this.pseth = this.bbox.maxy-this.bbox.miny;
		var wratio = (this.canvas.width-1) / this.psetw;
		var hratio = (this.canvas.height-1) / this.pseth;
		this.ratio = Math.min(wratio,hratio);
	}
	x( psetx ) {
		return (psetx-this.bbox.minx)*this.ratio;
	}
	y( psety ) {
		return (psety-this.bbox.miny)*this.ratio;
	}
}

function labelmapr( mapr, x, y, offset,labeltxt ) {
	mx = mapr.x(x);
	my = mapr.y(y);
	if (!labelmap[x]) {
		labelmap[x]=[];
		labelmap[x][y] = 1;
	} else if (!labelmap[x][y]) {
		labelmap[x][y] = 1;
	} else {
		times_used = labelmap[x][y];
		my += offset * times_used;
		labelmap[x][y] += 1;
	}
	if (mx>(mapr.canvas.width-offset))  { mx -= (offset*2); }
	if (my>(mapr.canvas.height-offset)) { my -= (offset*2); }
	if (mx<(0+offset)) { mx += (offset); }
	if (my<(0+offset)) { my += (offset); }
	return [mx,my];
}

function findBoundingBox( Pset ) {
	var minx = Pset[0][0][0], miny = Pset[0][0][1];
	var maxx = minx, maxy = miny;
	for ( var i=0; i<Pset.length; i++ ) {
		var contour = Pset[i];
		for ( var j=0; j<contour.length; j++ ) {
			var point = contour[j];
			maxx = Math.max(maxx,point[0]);
			maxy = Math.max(maxy,point[1]);
			minx = Math.min(minx,point[0]);
			miny = Math.min(miny,point[1]);
		}
	}
	return {"minx":minx,"miny":miny,"maxx":maxx,"maxy":maxy};
}

function flatten( data ) {
	vertices = [];
	dimensions = data[0][0].length;
	for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dimensions; d++) vertices.push(data[i][j][d]);
        }
	}
	return vertices;
}

function makeTriPset( mainPset, tris, mapr ) {
	dimensions = mainPset[0][0].length;
	vertices = flatten( mainPset );
	trianglePset = [];
	for (var i = 0; i < tris.length; i+=3) {
		triContour = [];
		for (var j = 0; j < 3; j++ ) {
		    ptindex = tris[i+j];
			x = vertices[ ptindex * dimensions + 0 ];
			y = vertices[ ptindex * dimensions + 1 ];
			triContour.push( [x,y] );
		}
		trianglePset.push( triContour );
    }
	//console.log(trianglePset);
	return trianglePset;
}

function drawPset( pset, canvas, mapr, labels, lastcontour, fillLevel ) {
	ctx = canvas.getContext('2d');
	labelmap = [];
	todraw = Math.min(pset.length,lastcontour);
	var pointindex = 0;
	dim = pset[0][0].length;
	for ( var i=0; i < todraw; i++,pointindex+=dim ) {
		//console.log("dpset"+i);
		var contour = pset[i];
		ctx.beginPath();
		ctx.moveTo( mapr.x(contour[0][0]), mapr.y(contour[0][1]) );
		for ( var j=0; j < contour.length; j++,pointindex+=dim ) {
			var point = contour[j];
			ctx.lineTo( mapr.x(point[0]), mapr.y(point[1]) );
			if ( labels>0 ) { 
				ctx.font="1em Verdana";
				ctx.fillStyle = "black";
				labeltxt = i+':'+j;
				if (labels==2) labeltxt = pointindex;
				labelpoint = labelmapr(mapr,point[0],point[1],40,labeltxt);
				ctx.fillText( labeltxt, labelpoint[0], labelpoint[1] );
				ctx.fillStyle = fs;
				//console.log(i+','+j, mapr.x(point[0]), mapr.y(point[1]));
			}
		}
		ctx.closePath();
		if (fillLevel==1) {
			//var fs = 'hsla('+360*(i*3)/(pset.length*3-1)+',100%,50%,0.05)';
			//console.log('fs',i*3,pset.length*3-1,fs );
			var fs = 'hsla('+360*(i*3)/(pset.length*3-1)+',100%,50%,0.2)';
			ctx.fillStyle = fs;
			ctx.strokeStyle = "black";
			ctx.fill();
		} else if (fillLevel==2) {
			ctx.fillStyle = "gray";
			ctx.strokeStyle = ctx.fillStyle;
			ctx.fill();
		} else {
			ctx.strokeStyle = "black";
		}
		ctx.stroke();
	}

}

// create a function to respond to filename clicks, used by build_testmenu
function mkfunc( testname, canvasid ) {
    return function() {
		currentTestName = testname;
		redraw( canvasid );
    }
};

function build_testmenu( canvasid ) {
	// load testOutput, from testoutput.js, and make a menu
	// testoutput.js is generated by cargo test -- --test-threads=1
	// and included in the main .html file as < script src = "testoutput.js" />

	names = Object.keys(testOutput);
	names.sort();

	// fill up the 'file' menu on the left hand side of the screen
	for (var i in names) {
		testname = names[i];
	    var menu = document.getElementById("menu");
	    var filenode = document.createElement("div");
		filenode.setAttribute( "class", "file" );
		if (testOutput[testname]["pass"]=="0") {
			filenode.setAttribute( "class", "file_fail" ); }
	    filenode.innerHTML = testname;
	    filenode.addEventListener('click', mkfunc(testname,canvasid) );
	    menu.appendChild(filenode);
	}
}

function drawTest( pset, tris, report, canvas, showlabels, fillLevel ) 
{
	ctx = canvas.getContext('2d').clearRect(0,0,canvas.width,canvas.height);
	mapr = new PointMapper( pset, canvas );
	triPset = makeTriPset( pset, tris, mapr ); 
	drawPset( pset, canvas, mapr, showlabels, pset.length, 0 );
	if ( fillLevel == 1 ) {
	//	for ( var i = 0; i < 6; i ++ ) { 
			todraw = triPset.length;
			drawPset( triPset, canvas, mapr, false, todraw, fillLevel );
	//	}
	} else if ( fillLevel == 2 ) {
			todraw = triPset.length;
			drawPset( triPset, canvas, mapr, false, todraw, fillLevel );
	}
    var reportbox = document.getElementById("report");
	reportbox.innerHTML = report + '<br/>' + tris;
}

function redraw( canvasid ) {
	canvas = document.getElementById( "mycan" );
	drawTest( testOutput[currentTestName]["json"], 
			  testOutput[currentTestName]["triangles"],
			  testOutput[currentTestName]["report"],
			  canvas,
			  labelsToggle,
			  fillToggle );
}
function redrawEarcutVersion ( canvasid ) {
	// this section creates earcut.js versions of each test from testOutput
	var canvas = document.getElementById( "mycan" );
	var testname = currentTestName;
	var jsondata = testOutput[testname]["json"];
	var data = earcut.flatten( jsondata );
	console.log("-------earcut start" );
	var result = earcut(data.vertices, data.holes, data.dimensions);
	console.log("-------earcut end");
	var rpttxt = "filename:" + testname + ".json\n num tris" + result.length/3;

	drawTest( jsondata, 
			  result,
			  rpttxt,
			  canvas,
			  labelsToggle,
			  fillToggle );
}


function labelsfunc( canvasid ) { labelsToggle = (labelsToggle+1)%3;redraw(canvasid);};
function trisfunc( canvasid ) { fillToggle = (fillToggle+1)%3; redraw(canvasid); };
function earcutfunc( canvasid ) { redrawEarcutVersion( canvasid ); }

function setupControls( canvasid ) {
    document.getElementById("labelsbutton").addEventListener('click',
		labelsfunc, canvasid );
    document.getElementById("trisbutton").addEventListener('click',
		trisfunc, canvasid );
    document.getElementById("earcutbutton").addEventListener('click', 
		earcutfunc, canvasid );
}

function main() {
	canvas = setupCanvas("viewer","mycan");
	setupControls( "mycan" );

	var testPset = [[[661,112],[661,96],[666,96],[666,87],[743,87],[771,87],[771,114],[750,114],[750,113],[742,113],[742,106],[710,106],[710,113],[666,113],[666,112]]];
	var testTris = [14, 0, 1, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9, 10, 11, 
		12, 13, 14, 1, 2, 4, 6, 8, 11, 13, 14, 14, 2, 4, 4, 8, 10, 11, 14, 
		4, 4, 10, 11];
	var testReport = "default shape, " + testTris.length + " triangles";

	//drawTest( testPset, testTris, testReport, canvas );

	build_testmenu( canvas );
}

main();

</script>


</body>
</html>



